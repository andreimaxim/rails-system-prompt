**Martin Fowler:** So, here is the final of Is TDD Dead conversations that we've been having over the past few weeks and this time around the three of us are going to tackle some of the questions that have come up. We've been having a Q&A app on the Google Plus system up to put together
the questions and we still have that app up and going. So if you want to add a question for us to think about, do add it to the app or use your
vote on the existing questions. We are going to be influenced fairly strongly by how many votes go on questions. We're not necessarily going to
be completely influenced by that but that certainly is going to be a factor. We're going to look at the higher numbers first. And the basic way
we're going to do this is it's going to be a longer session. We're going to aim at perhaps up to an hour. The first half an hour or so we are going to look at answering these questions. And then for the final half an hour or so we're going to try and sum up what we've learnt and what our feelings are about this whole topic. For that first part where we're doing the Q&A we're going to take turns and each of us is going to pick a
question and begin to answer it, give the opportunity for other people to answer it and then pick somebody else to answer the next one and we'll go around in a flow like that. And since I'm starting I get to pick the first person who has to pick something so David, it's you.

**DHH:** Excellent. Well let me just pick the one we have straight from the top. Mike Harris is asking what is an example of an open source project which has test induced design damage? What is an example of a project that does TDD right? I think that that would be wonderful if we had a
clear URL answer to both of those questions. And I think that that's actually one of the real problems in debates like this. Whenever we're debating technique in programming that's beyond what can be illustrated on just a couple lines of code, it's really tough because we don't have good shared context. The open source world is really good at producing frameworks and libraries and wrappers and adapters and all these other things. It's much less successful at producing full-fledged applications. Because most of the time people who work in open source, they work on their
own private applications and what they're sharing is the comments, the things they can extract for that. And that's certainly true for me as well. I think the last real open source application I worked on was in Sticky, which is more than a decade ago. Everything since then, every piece
of open source code that I've shared has been in the form of library of a framework. So we go into these discussions from very different contexts, right? We're all discussing on the basis of our own personal experiences and our own personal private apps and we're not sharing those apps.
So I think that that's definitely part of the problem and I think that's why it makes it so tricky. And I think it's also why sometimes it can seem like there's greater disagreement than there really is. Once you set down two reasonable programmers in front of the same piece of code and
ask them to evaluate whether one version is better than the other version, I've found that people have a tendency to come together. Not always,
but certainly much more frequently than if you just talk in the realm of philosophical differences or architectures or even patterns and if you
just use basically read me code examples and so forth, these sort of context-less snippets. So no, there's unfortunately not a great answer to that. I looked around just a little bit, I've seen some minor examples, but all these minor examples, they all suffer from the same fate, that they're not something that somebody's really working on. They're like throwaway experiments, which is why a lot of the discussion that we've had here and a lot of the opinions that I've formed on what people are doing have been formed off presentations. It seems like the one way you can find out at least somewhat what people think about certain programming principles is to see their presentations at conferences. So that's why I link to the presentation, the code presentation that the late Jim Weigwick did for the hexagonal rails architecture example, and at least he goes
through explicit code. It's not real code and it can be attacked for all those reasons, but at least it's actual code. So if you have a look at
that, that was one of the main things I pointed to as for design damage, so to speak. And for something that doesn't have design damage, I'd say a lot of the sort of Rails books that don't go into heavy testing technique and just throw the standard approach to it is something I'd point to as something that doesn't suffer from that. It might suffer from all sorts of other ills, but at least not from that.

**Martin Fowler:** Yeah, and I'd flow in as well on that in saying that, I mean, also one of the problems is it takes a lot of effort to really
understand the kind of code bases that we're trying to talk about. I mean, I do a little of this because I don't do any real work anymore. The closest I get is to be a spectator. I have gone into a couple of ThoughtWorks code bases and poked around to try and understand how it works and
to try and understand how they're using the tools. But to really get a sense of what's going on when you're looking at what a team of a dozen or a couple of dozen people have been working on over the period of a year, that takes a while. You have to really get a sense of it. And even then, you have to question how well is it really the same as if you were working on that team? Because in the end, it's the team that decides what
works for them and what doesn't work for them. I mean, I had a very good example of this. I was looking at a code base that was using one of these functional-ish Java libraries that's the rage these days. And I was looking at the code and thinking, I don't like this stuff at all. I mean, I can see what they're trying to do, create a lisp in Java, but really, no, it's not working for me whatsoever. Then about a few months later,
maybe six months later, the code got handed over to another ThoughtWorks team in another office, completely unfamiliar with a code base. I actually popped in and saw that team a few months after that, and they loved it. They thought it was great. It was really easy to work with. So it's
very hard to form a judgment, even when you actually see the code in front of you, when you've got a body of code, when you're not part of the team that's working on it.

**Kent Beck:** I'll point to JUnit as an example of code that was written very strictly test-first, and the design entirely piecemeal. The code
coverage, when I stopped being an active contributor, was very close to 100%. That's not to say it's perfect, or I would suggest that anybody copy everything about it, but it suffers from having overly clear interfaces. You have some Java syntax representing a test coming in, and you have pass or fail coming out, more or less. I think that's the sweet spot for TDD, when you have those kinds of really, really clear interfaces. What we're really talking about here is when the interfaces get more complicated, when calls to some service are part of the output or part of the input, and behavior in a browser is part of the specification of the input and the output. At that point, do the costs of TDD outweigh the benefits? JUnit's not going to be your example of that. I would say, if you have an example, write it up. Publish it, get it out there, warts and all, and you'll be doing the community a service, for sure. I think, just as one point to what Martin was saying, too, with the context that you can't always evaluate, I think this is exactly one of the other things I had in my keynote at RailsConf, which was beyond just the TDD thing, was this notion of whether what we're doing is science or not. I think Martin's comments exactly pinpoint that what we're doing, it's very hard to
make it scientific, to evaluate whether a technique or principle or process truly works or truly does not work in an objective sense. It's virtually impossible, which is why I think it's not even helpful to try to do that. And I think that we're sometimes doing ourselves a disservice when we come into trying to evaluate these more, basically, social approaches with our computer science hats on, that we think that we can deduce it all to true or false statements, which we just can't, which is why these discussions are never going to be fulfilling in the same sense of mathematical proof that we'll arrive at the truth, because the truth, we're never going to arrive at that. It's going to always boil down to, well, depending on, in this context, with these people, with their preferences, and so on and so forth. That doesn't mean it's not worth debating, though. And I think that that's the best we can arrive at. The best we can arrive at is like, hey, here's my experience, here's what I think of it, this is why I think of that. You're never going to get like an A or B or whatever final solution to it. You're just going to get a bunch of experiences and a bunch of opinions, and then it's your job to sort through that and figure out what makes sense.

**Martin Fowler:** I'd like to add to that that whilst, yeah, you can't repeat experiments, right? That's independent verification is the bedrock of science, and there's just too many variables to ever be able to repeat it. But I find that a scientific mindset is personally very helpful. And even though I know that it's not really science for me, if I say, well, I'm going to try this three times, and then I'm going to compare, or I'm going to gather some data, and then I'm going to analyze it. For me personally, I find that very helpful. It feels insightful to me. At least it feels more insightful to me than just popping off with some opinion. So I like to carry a scientific mindset into my own workflow, but I'm not going to claim any kind of universality. And I think anybody who's looking for that kind of certainty, you would find it just as easily in political science as you would in computer science. And that's the end of that answer for me. And that's the end of that answer for me. Yep.

**DHH:** Kent, do you want to pick a question?

**Kent Beck:** Sure. Keep scrolling around. But here's one that I found interesting. Graham Lee asks, what could change about the way we write software to make TDD redundant or obsolete for Kent and Martin? What a... and then it scrolled some more. Thank you, Google. Let's see. What could change about the way that TDD is performed to make it useful or beneficial for David? So since y'all aren't jumping in, boy, we are a well-oiled machine. At this point, you know, we have all the patter worked out. There's no chance of dead air. I'm proud to be part of this team. I'll jump in. My RIP TDD post, I think, sets my position out pretty clearly if sarcastically. TDD solves a bunch of problems for me. And I'm happy to
have those problems solved some other way. But what I'm not happy to do is to give up on TDD and just leave those problems unsolved. So working
from faulty memory now, I think the main points I made there were about confidence, about always having a bite-sized chunk of work next. I just
love that about TDD where there'll be some implementation. I'm thinking, oh, God, I can't even imagine how I'm going to implement this. Well, but can I write a test for it? Well, sure. If I get 2 and 2 in, 4 has to come out. But how am I going to get to 4? Oh, well, I can write the test. So I write the test. And in writing the test, I have to go examine this and this and this. And I go through the calculation in my head. The test is there. It fails. I think, oh, well, I know how to do this one. You know, maybe not the general case, but I can certainly get this one to pass. So I move very easily from this realm of being overwhelmed to, you know, I'm in a dark room, but there's a spotlight one step in front of me. So I can step there, and then there's another spotlight appears. I love that effect. And I think that's something, when I forget it and I come back to it, it's such a comfort for me to just not have to feel like I have to solve the whole problem at once. So whatever approach I take, I
want that sense of being able to attack big problems piecemeal. I took Brian O'Sullivan's Haskell course, which I would – anybody who gets an opportunity, Haskell will definitely mess with your head. And that was the thing that I found most disturbing is I had – in Haskell, it's a very universally quantified language. You know, you write these statements, and they're just supposed to be true for absolutely everything. That's kind of the mindset. And letting go of this, well, I get one example working, and then the next example, and, like, letting go of that and trying to switch my brain over, that was the thing that was most uncomfortable for me in trying to learn Haskell. So whatever workflow I adopt, I need to have that sense of I can make piecemeal progress. And I can see it concretely. I used to have four tests, and now I have six tests. And, you know, assuming I'm not being an idiot, I'm making some progress. If I could have a language and an environment and a workflow that gave me that same sense, I'd be perfectly happy to use it. But I'm not content to give up on it just because sometimes TDD is hard.

**Martin Fowler:** Yeah, for me, it's not so much a question about other changes about how we write software that would make it obsolete as it's the applicability in different contexts. I have had more than once the experience where I followed TDD in a fairly mechanical kind of way, just doing one example, next example, heavy refactoring after each step to eliminate duplication, which is, of course, the often missed point. And I've blundered into a design, and I look at that design and think, oh, that's really nice. I might have been able to come up with that myself. I'm pretty bright, so obviously I could. But I don't think there was a certain low stress, rapid unhurriedness that really works well for it, and
that's really nice. And that experience is one of the things that kind of makes me quite a fan of the technique.

**Martin Fowler:** Having said that, a lot of my programming that I do, the way I generate most stack traces these days is through the tool chain for my website. And much of that is I'm doing little bits of transformation, seeing how it looks on the web page. TDD is just unapplicable in
that context for me. I can't figure out how to make it effective at all, and I don't worry about it. I do the piecemeal pieces because I do one
little task at a time. That, I think, is a very important part of programming, breaking it down to the little steps. I have a very good regression test suite, which is to build the entire website and diff it against the one that I've got going, which is very good at finding mistakes. And that workflow operates in that context. But there are definitely cases where I've had the opposite. So when I built my little info deck structure that gives you a kind of slidish-like thing if you've seen any info decks on my site, you've seen it, then suddenly there's a lot of application behavior. If I jump to this slide, is the correct slide loaded? If I build backwards, do the builds appear in backward order? That was very
nice to do in a TDD style. And that really helped, especially since I was working in JavaScript, which is a, you know, well, actually I was working in CoffeeScript, which is the language that makes JavaScript almost bearable. But I mean, I'm in an unfamiliar environment, in a nasty language, with this horrible DOM world around me. It was very comforting to have that test bait there. So for me, it's a matter of context. Some contexts are very suitable for TDD, some contexts less so. And then different people, of course, bring their own personality into that context as well. So it's natural, but some people will find some flows work more than others.

**DHH:** I think that actually echoes my own experience very well. And it also echoes my dissolution with TDD as sort of overarching operating flow of how I do programming. Because first of all, my introduction to basically regression testing and self-testing code was through TDD. So the initial rush was, oh man, this is wonderful. I'm getting this great regression suite. I really like that. I really like the safety that gives me and the comfort that gives me to make changes. And then later, coming out of that, you come out with a feeling like, well, let me apply this to everything. Because obviously, this is a great feeling. So if it's a great feeling here, why wouldn't it be a great feeling for everything else? And then I guess I just sort of slowly realized that as I kept trying to apply it to different aspects of the work I was doing, which is web
applications, MVC-style web applications, I was just finding a lot of areas where it wasn't feeling good. Like, the jumps and the hoops I had to make to make it feel good were worse than the feeling got out of it, which is, of course, sort of the genesis of this discussion, right? And I
think that that's really what crystallizes it for me, that I just can't use TDD for the majority of the work I do. I can't use TDD for the majority of the web application development that I do. I can't use it in a way where it helps me. And when I try to force it, and when I see others try to force it, I see negative things coming out of it. That doesn't mean that, as Kent was saying in the beginning, when you have that, oh, 2 plus 2 is supposed to give 4, how do I come up with the implementation for that? I completely agree. That's a great flow. It feels good. That's a natural sweet spot for TDD. The amount of time that you're in that cycle for most web application work, it's a pretty small percentage. But again, it doesn't mean that the regression suite, the self-testing code, all these other artifacts that come out of the TDD cycle, those things are valuable on their own, whether you're doing TDD or not. And that's where I really found the main benefit, that I could realize that all these good feelings I was getting from TDD, for me at least, they largely came from the regression suite. They largely came from building up the suite. They didn't come from the design-driven part. They didn't come from, oh, the testers are supposed to tell me when I'm doing a bad job at designing things because they're too tangled, or they're not in enough isolation, or all these other things. I never realized much benefit from that flow. I realized immense benefit from the regression flow. So I think that that's where I'm coming from when I say TDD taught me to realize the benefit of those things, self-testing code and regression suites. It never fulfilled the dream of driving better designs for me. So I'm leaving that behind and saying, OK, well, when there is the case when I have the 2 plus 2 and it's supposed to give 4, which has happened. I've written markdown converters or similar things like that where you know exactly what the input and the output is supposed to be. Wonderful. I'll pull that sort of screw number 40 out of my toolbox. It's just not the main operating loop that I'm in when I make web applications, which is I think that that's a conflict that I see, that a lot of people really want it to be the main operating loop that applies to the bulk of the work that they're doing. That's where it just doesn't play out for me.

**Martin Fowler:** But I want to point out here that what you've just described is exactly how anybody should take on a technique like TDD. You
look at it. You say, oh, this looks like it could be useful. You try it out. And you thought, oh, I'm getting some growth benefit here. You overuse it because naturally when you're trying to work with a technique, look how many times in the Ruby world we see this with metaprogramming. I
mean, people overuse it. And then they discover, oh, yeah, that doesn't really work there. And then you begin to settle into a mode that works for you and find out where is it appropriate for your particular team that it fits. You also look a bit further and say, OK, well, what's going on that's more than that? TDD, you've described as a gateway drug to self-testing code. And self-testing code is a connected but different thing
which has its own value. And so you've kind of gone beyond the kind of surface technique to probe further. That's exactly what I would want to see anybody do when learning any technique like this, is to go through that kind of thinking process. And where they end up with their workflow and what percentage of the time do they write tests before and after doesn't, I don't care. If it works for them, it's fine.

**Kent Beck:** I will say my experience is different than David's in that there's a moment in development where something's hard to implement. If I can just get up from my chair and walk outside for a minute, sometimes I can think, oh, if I had an X, then my problem would be easy to solve. And I teach this to my coaching students all the time. Make the problem easy and then solve the easy problem. Warning, making the problem easy may be hard. So you have to apply it recursively. But this moment where you think, oh, but if I had a little object that did da-bum, ba-bum, ba-bum, then this logic that's scattered in these three different places, that could all be isolated. And that's the moment where I find the design feedback of TDD to be really helpful. Because here I've got something. It's gotten messy. I've had some sort of insight. And I think, well, if only I had this kind of API, these functions, this object, these messages, then I'd do this a lot. I'm going to separate these two dimensions
of complexity from each other. I'm going to put this in one object and this in another object. And then they're both going to be simpler. That's what you're trying to do with software design, is this synergy where the sum of the interaction of two abstractions is more powerful, them working together. So that's the moment at which I really appreciate TDD. Because I have an idea of an API in some kind of abstract form. And I want
really rapid feedback, because I'm as self-deceitful as anybody else. When I have that idea, I want to get rapid feedback about whether that API actually looks good in practice. And I don't know a faster way to do that than with TDD. I want to get feedback from a usage. Here's an example usage. And then I want to see the implementation, because sometimes the implementation will inform the API. Oh, I need that parameter too, or I can't compute this result. And oh, now the functions all have four parameters. And that's kind of ugly, so let's go in some different direction. So for me, in my workflow, because I like that moment of let me make my problem easy to solve before I solve it, I both crave it and enjoy it
and look for it. TDD as a piece of design feedback is a really powerful, powerful tool for me at those moments. And I'm still struggling also with these moments when I'm not in there. And I've got the outputs are side effects in three different services. And the inputs are from six different services and how to use TDD for that. Like, I don't know. I get in the situations, and I look other ways for feedback. I mean, Command-R is a great piece of feedback. Just reload the damn browser and see if it looks good. It's really easy to implement. It's not persistent. Sometimes it can be slow, et cetera, et cetera. But the testing framework's already in place for that. So if what I want is feedback, sometimes that's all I can do. But what I'm hoping for, the moment that I'm hoping for is that moment when I think, oh, if only I had a blah, then the rest of this stuff all is going to fall out. And then I'm back into a world of constrained inputs and outputs. And I can TDD for a while. And I can get good feedback. And I can have confidence in the code. So my experience, I think, David, it sounds like your, I guess we'd call that programming strategy and mine are a little bit different along those lines. Next question?

**Martin Fowler:** I guess that's my turn then, isn't it? So I'm going to go down to a question from Tudor Pavel. The issue of experience was touched upon a bit in part four. How do you think a lack of design experience affects TDD? And how do you think TDD works with an inexperienced developer? So I felt, from observation primarily, because I came across TDD when I was relatively experienced, I felt that one of the great things for a less experienced person is that TDD does kind of force you to do these small byte-like pieces, which is a good thing if you're not an experienced person. It's also good in that you are kind of led a bit as to thinking separating the interface from implementation, which is one of the hardest things in software when you're working with pieces. Now, it doesn't, however, guarantee a great result. I mean, if you're not got good design experience, you're not going to come up with great designs because you're not experienced. You have to have that experience and modulo
of talent, et cetera, et cetera, to get there. And typically, people, when they start with TDD, they will make the mistake of not refactoring enough and building up something suboptimal. But when you assess about the role of TDD in that cycle, you can't compare an inexperienced developer's output to an experienced developer's output. That's an unfair comparison. What you have to compare is what would have the inexperienced done
without TDD's help. And that's, of course, an impossible comparison to make. We can't measure this, et cetera, et cetera. But I think it does seem, from what we can tell from observation from new people who are coming in at ThoughtWorks, it does seem to be advantageous. And the fact that it produces a self-testing code base is not to be sneezed at. Because if you've got poorly designed code that's got a good test coverage to it, then you've got the important prerequisite to refactoring it into good shape later. I mean, it would be better if it was in good shape in the first place, obviously. But the fact that you've got the tests is a big step. If you've got a crummy code base that's got no tests, then trying to refactor it, I mean, you've got to start by building up decent tests. So at least if you've got poorly designed code with tests, you're a step further than most people are. So I think for a less experienced person, TDD has a lot of attractiveness in that sense. It's not going to be a replacement for experience. But it is a good step forward. Now, if you're experienced, then I think there's a lot more choice and things involved. And you pick the right tool for the job, et cetera, et cetera, et cetera. And you've got a better sense of what you'll go there. And you'll make better design decisions with your experience with TDD or without TDD. But I think particularly for people who are less experienced, it is a good starter point to bring in.

**DHH:** I think that that touches on the point that we talked about just before there. TDD is the gateway drug to regression testing. It's a gateway drug to understanding the value of self-testing code. And that was the process that I came through. When I started with Ruby programming and programming in general, TDD was sort of just getting going. So I got the TDD message right from the get-go. And I found it definitely valuable. It was a great way to enlighten the value of testing. And as a set of training wheels to reach that point, I'm very thankful. I'm grateful that I went through that. And I think that really works. And I think, as Martin was saying too, you have to overuse something to realize what the
proper use is. And I'm a big fan of that, that you can't find the limit unless you step over it. What I then find is that, at least to me, the discussion didn't progress sufficiently. Partly, perhaps, because some people worried that if you had a more nuanced discussion of when TDD was a good fit for experienced people, then you would confuse the young ones. Like, oh, we can't get off message here. The message has to be simple,
and it has to fit in the tweet. And it has to be TDD all the time, or you're not a good developer. Because then you would, through fear and intimidation, get people to realize that they have to eat their vegetables. Right?

**DHH:** That's the part that wasn't working well for me, and that was the part that when I later arrived at sort of I had the concept of knowing the value of self-substantive code, and regression tests, and then seeing what got me there no longer was as helpful. It was helpful in some situations, under some circumstances, but it was a minority feedback loop I could employ, right? So that is to say, I'm always skeptical when people like, oh, young people or somebody inexperienced coming to something, they need such simple and direct and bombastic declarations about the
value of something, because otherwise there's no way they would do it. I think that reveals that sort of uncertainty and lack of confidence in the value of what you're teaching. If you cannot even open the possibility that TDD is not going to be a good fit for perhaps if you're doing web applications, even a majority of your work. That doesn't mean it's without value, it just means that there's a large part of the work that happens in web development where it's not the best fit. And that maybe command R is actually on par for certain parts of the application when you're working on the view, for example, and that's good enough. But I found such a hesitation from a lot of circles of being able to deal with presenting that ambiguity and that's the no good part in my book. Anyway, maybe that didn't even answer the question, but that's my input on it.

**Martin Fowler:** Well, I think it brings up an important point. I mean, I agree with you. I don't like dogmatic statements of you must always
do this and all that kind of thing, and it really gets up my nose. And I do feel I always want to present techniques with the trade-offs. I'm actually always suspicious when I'm writing up a pattern or a technique if I can't talk about reasons when you shouldn't use it, and trade-offs against it. If I can't find arguments against it, then I'm worrying that I'm not really analyzing things properly. But one twist of this that we do have to remember, but I find a lot of more experienced developers forget, is that we do have to keep repeating the introductory stuff because
there's a lot of new people coming into the profession. And I see a lot of, and I'm not saying you're giving this, David, but I mean, I see it out there generally, a lot of snarkiness about aimed at people who are targeting people who are new to the profession and saying, and starting from first principles and beginning to explain from the beginning and saying, oh, this has already been talked about. This is old stuff. We don't
need to say this again. But we always have to constantly do this. We constantly have to keep repeating. And that's an inevitable part of any profession that's still having people come into it. And we'll always be doing this. And I think a lot of people need to remember that. But that has to be part of the picture.

**DHH:** I think that that also is part of the sort of why now for me. Why is it now we're having this conversation? And I think part of it is that the current group of active participants who are talking at conferences or writing blog posts or books or whatever and are carrying on the message. To me, and maybe that's just a natural tendency, sort of, oh, you want to add your own spin to something. You don't just want to repeat
the first principles. And then you add one little spin on it to sort of, oh, well, that's my brand of something. Then somebody else takes that and builds upon that. And then at some point, 10 years down the road, you're quite far away from what you started with. If you just started with
those original first principles as they were presented and you just repeated those, maybe you'd still be in a great place. But through 10 years
of mutation, where everyone has to inject their own little trademark into it, you end up in a place that's far removed from the original principle and is not necessarily a good place to be, which is why I think a lot of times it's almost like you need a reset button. Sometimes when you can't find a memory leak in a piece of code, you just say, well, when it reads 600 megabytes, just kill the damn process. It will start over. It's a very crude technique. But I think sometimes it works. And that's where I'm coming at when I'm saying TDD is dead. Current mutation and accumulation of trademark cruft and so on need a reboot. Control-Alt-Delete. Let's go back to first principles. Wipe out a bulk of all the stuff we've built on top of it. Let's try again. I understand that that is a crude technique. And you have to weigh the, oh, well, there's some good stuff here. But there's also a bunch of bad stuff. And sometimes I feel like you just got to get that reboot. And then, all right, it'll take a little while to get back up to the good stuff. But you've gotten rid of everything. You've got to have a sin flood of all the stuff going out for you to have a chance to grow again. And then, yes, in another 10 years, you'll probably end up in the same place. And you'll probably have to do the whole thing all over again. But such is the nature of what we do.

**Kent Beck:** And I think maybe that's my gut reaction to your keynote was at that level. There's certain good effects. I think programmers are prone to masochism. We'll do things over and over again. Or we'll put up with complicated systems and just repeat it or be in dysfunctional social relationships at work and figure, oh, well, people just always yell at me. Or I grew up being taught to expect that kind of stuff. I'm just
not going to feel confident. I'm not going to be able to measure progress. I'm not going to know whether I had any impact. And I'm happy with the reboot back to first principles, especially since I published the first book on it. But what I don't want to lose is this sense that the expectations of programming work have evolved in the last 10 or 15 years in very positive ways. I should be able to feel confident. Oh, yeah, this works. I should be able to point to my contributions. I should have productive technical collaboration. I just expect that that's part of my work
day. Those things weren't true. They are true now. I don't want to lose those. If I had to sell TDD to get those, I would happily do it. Because to me, that's far more important, that I can be my whole self at work in a way now that I couldn't when I started professional programming 85 years ago. That, I don't want to cut loose. And I don't want the baby to go out with the bathwater. For me, TDD was an important part of achieving those effects. But it's really the effects. Is Kent frozen?

**Martin Fowler:** Kent is looking a little frozen. OK, Kent's frozen. I'll follow up just a little on that, because I think that's incredibly important. And I think that the debts, when I came into programming.

**Kent Beck:** Technical problems that you can use TDD to solve.

**Martin Fowler:** You just froze in the middle of a second there, Kent. Anyway, I'd say that that is extremely pivotal. I think that that's why a lot of things came together at the same time. So you had TDD, you had XP, and then you also started seeing programming languages like Ruby that took that whole message of you're supposed to be able to feel confident and secure in your code and infuse this notion of happiness. Which I
remember when I first picked up Ruby, a lot of people laughing at that. Like, programming's not supposed to be easy. It's not supposed to be fun. You're not supposed to be happy. This is supposed to be hard work for serious people doing real engineering science stuff. And here comes Ruby. And I tried with Rails to build on that, both from the angle of the TDD world and from what Ruby was infecting into it. Which is why I think we're in a different place now. And the battleground, it's a different battleground. At least for some aspects. I still understand that there are pockets of resistance. Sort of like the Japanese island that was still fighting World War II 40 years after it closed out. And maybe that's even overstating the point that these pockets are much larger than that. But we can only react to what we see. And what I see in Ruby community and like-minded communities that I deal with the most is that we now take this for granted. Like, this is now, like, it won so greatly that it's part of just the same thing with Agile, right? That many of these principles, they're no longer the fighting frontier. Like, they're no longer the barricades that we have to stand on. Because a lot of times, we just take this for granted. And I see that Martin is shaking his head. Because
I'm sure he walks into a lot of meetings with people who go like, what? Agile, TDD, testing, Xcode, you're crazy.

**Martin Fowler:** No, it's not that. I mean, Agile has the label victory, as it were. The problem is lots of people saying, oh yes, we want to
be Agile. Could you please design our mandatory process, the Agile software development, and give us a training course and a tool so that we can execute it in our company in the next couple of months? I mean, there's a lot of people talking Agile and not necessarily doing it. And that's
why you see a lot of frustration from people like Brag Dave and other folks about there was a real struggle there. And that's what happens when
you get in the later phase of something. Because you get this misinterpretation. The fancy-schmancy term I use is semantic diffusion, where the
meaning of something gets lost over time. And that, to some extent, one could argue, has happened to TDD, but much less so, I think. With Agile, it's a much bigger problem, because it has a much bigger scope. So the difference, though, and it's to some extent true on the testing front as well, of course, the difference is we're no longer going to be thrown out of a client where we're successfully delivering software, but they discover we've been using Agile. And you have that problem. We really like what you're doing, but you're not doing any of us Agile stuff, which is what we were told by at least one client back 10 years ago. That no longer happens. But now we have the other thing of, we've been doing Agile
for 10 years. Here's our mandatory process. And you're facing a different set of problems talking to those people.

**DHH:** Which is, I think, the reboot notion, that sometimes there's just an accumulation of cruft. And usually happens in technical projects too. Most technical projects, most code bases, who get to live for 10 years, are full of cruft. Not all of them, but I'd say that that is the natural law of what is just happening over time. Original ideas get diluted. They get watered out. It reminds me about a lot of other things, what's it called, this Pinkberry. So Pinkberry is this frozen yogurt company out in California. And when they first started, they had two flavors. There was tart, and then there was, I don't even remember what the other flavor was. And it was really popular. They were offering this incredibly simplified formula that was very different from everywhere else, where you had to go in, and then you had 1,000 different choices of ice cream
you could pick. So there were lines out the door. And what happens, 10 years later, they have the same inflated menu. They have the same sort of overreach of these things. And I think that this just happens to most good ideas. Most people cannot just leave good ideas the fuck alone. Like, it's done, OK? This is a base where we're happy with where we are. You're making it worse by building on top of it. And I just don't think we
can't, as humans, leave things alone. So oftentimes, in the beginning, maybe we improve things marginally. And then we start detracting from them. And that goes with ideas. It goes with movements. It goes with products. It goes with programming communities. It goes with programming principles. I think at least just realizing that that's a mechanism that's going on, that that's the natural thing things are going to be drawn into, gives us a little bit of a bulwark, or at least some motivation to deal with it. And just saying, well, no, we're not going to accumulate that. We're not going to have all the semantic diffusion. I think that that was perhaps when we got started with this. Like, what is TDD? TDD is a very broad tent these days, in the same sense that Agile is a very broad tent. And you can find people under that same tent who say, oh, I'm doing Agile. And then you talk to another guy who says, oh, I'm doing Agile. And they're doing the exact opposite things, right? They call it the same thing. But it's impressive.

**Kent Beck:** The service that you provided for me, David, is as somebody in on it very early who had to invent from first principles, I don't
see that going on. Because I walk into a situation, and I say, well, how am I going to get feedback? How am I going to feel confidence? How am I going to break the big problem into little pieces and get feedback? I reinvent TDD from first principles every time I program. And so I just kind of, you know, I hear that other people are talking about it in other ways. But it doesn't, like, I can't imagine somehow that other people aren't having that same experience. So I appreciated the waving flag. And yes, you have to wave the flag pretty hard to get my attention sometimes. That said, OK, well, this is turning into more dogma. It's accumulating barnacles and seaweed. And it's time for some scraping. And so, yeah,
I would like to thank you for that. I'm also glad that it only took us three hours to get to the first F-bomb. So that was, I still, I took the
under on 42 curse words. And I'm still winning big, big, big, though. So that's good.

**DHH:** Oh, you better be careful. We've still got 10 minutes to go.

**Martin Fowler:** I think I've been speaking a little too long.

**DHH:** I think that's exactly the part of it. Because I often feel the same way with Rails. I feel like I'm still doing majority of the same Rails that I was doing 10 years ago. And then sometimes I see what people do with it. And I go, wait, what? Why? Why are you doing this? Why are
you making things so hard on yourself? Because I'm still approaching it from first principle, right? And then I see sometimes it shocks me when
I walk into a situation where people are using something that I still develop and I developed. And I see them using it in ways where I just go,
oh, this is not good. How did you get here? Like, how could you go from what we had to what you came up with? It just seems like such a long road that's so much harder than just going through the first principles. But I think that's just a mutation at work. Like, every single time somebody new gets in and they're told by somebody else who entered the community or whatever at a certain point in the timeline, they all mutate, right? And at some point, it can be very hard to recognize the final stage of the event.

**DHH:** Evolution that things often go through. And you cannot even recognize it at the end. And I think you're especially susceptible to this
when you were there for the first iteration, right? Like, you saw the pure form. And now you have this cut material that's left at the end. And
you just go, this is almost not recognizable, to the point where it's almost a point of disbelief, where you're like, I can't really imagine that people would actually do this. And then they do, and you're like, whoop.

**Kent Beck:** I remember the first oopsla where extreme programming was getting a lot of attention. Jim Rumbaugh took me aside. And he said, Kent, in 10 years, you're not going to be able to recognize what people have done to this. You have a great idea. This is really powerful stuff. And it's out of your control now. And it's all going to hell. And I thought, at that point, I'm like, no. I'm in charge here. I can control how this works. And lo and behold, yeah, he was absolutely right. So Jim, thank you for that warning. I appreciate it. I'm sorry that I didn't listen to you at the time.

**Martin Fowler:** But had you listened, would you have been able to do anything very much differently?

**Kent Beck:** No, not at all. Oddly enough, this is what success looks like, right? These kinds of mutations and things. Because the alternative is the thing just gets lost, right? And it's always this trade-off. One of the questions, Chris Morris's question, saying, is the problem with TDD due to its misuse? Or is it inherent in TDD? Well, it's very hard to tell. And you have these with all sorts of things. Because it's very hard to get a sense of what the original thing is and what the variations. And you inevitably, as you get success, are going to have more of this semantic diffusion. All we can do, I think, is we can keep talking about what we think are the basics, what we think are the good lessons that
we've learned. I mean, not all of those barnacles are bad. Some of them are actually quite helpful. And keep refocusing on that. And it's always going to be a somewhat messy conversation. Because as David points out, we're not in a scientific world. We can't have replicated experiments.
It's all very well for scientist people to put them and say, oh, well, you can't know anything without measurements and all that kind of stuff.
But in the world where we live in, we don't have, we can't fundamentally measure our output. And we're always going to be stuck with this kind of situation. And we just have to deal with the reality as it is, not wish it were some other reality.

**DHH:** I think the saying of you either die the hero or you live long enough to become the villain applies to these things. That this is, in many ways, an inevitable process. Which is why, I think, this notion of reboot and why it's also healthy, I think. So when I came into Ruby, it felt like it was a reboot of a lot of ideas. That whatever went before it, whether you came from Java or you came from PHP or whatever, here was
a community that was going to say we're going to reboot a lot of these ideas. We're going to scrape so much away. We're not going to do XML sit-ups. I remember that was one of the taglines we had in the beginning. We're not going to do all of this stuff. And then, at some point, since then, there's been other reboots, right? So functional programming comes in and all of a sudden, there's a reboot. We're not going to do a bunch of this stuff. Or Node.js and the rise of JavaScript, too. We're not going to do this stuff. And I think that these reboots are really healthy. I think they need to happen. Exactly because, as we say, regardless almost of what we do, we're going to get to a point we can delay it, perhaps. We can sort of restate the original principles. And that can delay things. I mean, I'm obviously biased. But I feel like we've been able to delay the inevitable with Rails for quite a long time. I certainly wouldn't have thought 10 years ago that I would still be working on Rails. And I think the sort of hallmark of an idea lasting a long time, same with TDD. I don't know, Kent, if you thought that when you first came up with sort of red-green refactor and other ideas for this that we'd still be talking about 10 years later. But that's success. Success looks like becoming the villain, which seems true for Rails. Like, Rails is the villain for tons of people, right? Like, oh, it's the most terrible thing ever,
blah, blah, blah. But I also think as to the point of, oh, is there something fundamentally wrong with the idea? Or is it just the people using
it wrong? I remember before I got into Ruby, I did a bunch of PHP. And I was like, people keep slacking on PHP, saying, oh, there's this terrible language. It leads you to terrible things. And I was on the other side saying, no, no, no, no. If you just use it right, it's actually great,
right? So everything is a continuum of that, right? At this point, I am on the sort of end of the scale where I'd say, yeah, PHP encourages you
to do some things that are not great in a wide variety of situations. Where other languages and environments do not provoke those same encouragements. I think for me, at least, TDD is on some scale. It's not the same place. It's on some scale where in some situation, it encourages you to do things that I don't think should be done, right? That's where the whole test-induced damage and so on comes from. And it's completely legit
to say, just like a lot of people who program PHP say, well, you don't have to do those things. You don't have to get dragged into that. You don't have to use the bad parts. You can, with enough self-discipline, with enough sort of effort, you can avoid what the thing is pulling you towards. So you can write beautiful PHP code. That's true. I think that's true. I think it's hard. And I think you can apply TDD to the entire stack of your MVC web application, perhaps, and come out on the other side with something that's not damaged. I think that's even harder than writing clean PHP.

**Kent Beck:** And my experience doesn't, I don't intend to invalidate that experience, but I just haven't ever experienced that, which is another part of the intensity of my reaction to what you said. I just never ran into that. Any time I can break off a piece of a problem into a useful abstraction, I'm more able to apply a TDD kind of workflow to it, and then all the rest of my problems. The big goals I'm trying to achieve, back to confidence, and significance, and technical collaboration, and being able to create long-term value, those all get better. So I think we
still have some very interesting unanswered questions out of that. Like, what is the difference? Is it really, like, my suspicion is if we were
just better designers, this wouldn't happen. You don't have that suspicion, near as I can tell. And to me, that's, like, moving forward, we just have a couple minutes left, but what I want to continue to explore first is other avenues to these same big goals of being able to bring my whole self to programming. What other than TDD can contribute to that? And what skills would I need to apply TDD to more of that? And then, really, especially this question of, is it just a matter of design? And if we were better designers, we'd be able to use it more widely. Or is there really something inherent where Command R is always going to be with us? And so that's what I'm going to be exploring over the next year, two years, for sure. Doing experiment, the way I do that is, I think, the way both of you guys do it, too. Let's do experiments. We'll do the Goldilocks thing. We'll do it too much. We'll do it not enough. And that's how we figure out how much enough it really is and where the trade-offs. Try to figure out, oh, it worked here, didn't work here. What's the difference? What was the trade-off involved? So I come out of this set of conversations firmly contradicting you, David. TDD is not dead. But perhaps, like the phoenix, it needs to rise from the ashes a little bit. And thank you for setting fire to it. But that's where I'm going. What can I do? What skills do I need to gain to get those effects that I want over the long run?

**DHH:** Yeah. I'd say that, for me, the purpose of getting involved with this discussion was as much to give space to people I've talked to where TDD has not worked for them. And they've been sort of hidden in the caves because they felt like this is actually not kosher to talk about. It's not politically correct in programming circles to talk about areas where TDD is not feeling safe. And those areas were TDD's not feeling good. Because what they usually got accused of was that either they were not professional, they were just not doing it right, they hadn't learned it right. And that exactly goes to all those feelings you're talking about, Ken. They were not feeling confident. They were not feeling good. They were not feeling valued. They were not feeling. They were feeling like they had to do this because this is the way we do things around here. And when they had experiences that countered that, when their personal experience butted heads with the industry norms of TDD, universal good all the time. I'm paraphrasing here. But then they felt crappy about themselves. And I thought, well, hey, I don't do it all the time. I went through the process with TDD where I did it too much. Then I backed way it off. I learned the wonders of regression testing and self-testing code. That's the main value for me. Hey, if you're in that same situation, if you're trying to apply TDD and it hurts in ways where you can't just reconcile the hurt with, oh, well, I'm just inexperienced. The hurt is good. I've heard that a lot of times. TDD is supposed to hurt because when it
hurts, it points out the pointy things. And if you can just embrace that hurt, then you'll see enlightenment and you'll get to the wonderful code, which has a little bit like smells. I think there's something to that. Sometimes bad things hurt. If you stop doing bad things, it doesn't hurt anymore. And other times, it's the technique that's hurting. It's not the original thing that was bad. And at least just opening the sphere of acceptable reactions to be, hey, TDD doesn't work on this end. I don't have to feel bad about not doing this. I don't have to feel bad about not being able to unit test every single piece of my MVC layer cake. I don't have to feel bad about applying it maybe just 10% of the time, maybe 5% of the time. I don't have to feel bad about my testing pyramid not being a pyramid. Maybe it needs to be on its head. Maybe I need to have more system tests than I have unit tests, because that's the configuration of my app, is pulling things together in such a way that it's more valuable to test integration between those things than it is to test individual units of behavior. That should be an acceptable answer as well. And for me, it seemed like the range of acceptable answers was very narrow. And when people weren't falling within that narrow band, they were being ostracized and ridiculed in ways that made them feel shit. And I never really got that feeling personal, because I have a tendency to not give two hoots or fucks about what people think about what I do. But I felt a hindrance to people who were exposed to that, who talked to me in private, because that was the other part, right? There was a lot of rah-rah on the internet at large, with people saying, oh, TDD is wonderful. Here's how it's great. Here's how the hurt, you just need to embrace it. There were very few people talking about, eh, it's not really working for me. They didn't want to say it in public. They were afraid to say it, because they felt like that would expose them as frauds. It would expose them as being unprofessional programmers. And they certainly didn't want that on their resume. I've seen that even on actual job resumes. You must be doing TDD. Otherwise, you don't apply for this job, where I just go, Jesus. It's kind of like the same thing, oh, yeah, unless you have 10 years of Rails development, please don't apply, where you just go, like, how can you use that as a filter? And so having at least a debate out there, and for people to figure out, hey, maybe it's OK that I don't do all the things in that order that's been prescribed, expanding the acceptable level of how we approach it is helpful. And I feel very comfortable expanding that without losing the baby. For me, the baby is the self-testing, regression code, feeling comfortable in making changes, and all those things. So there's this large body of experiences and values that we all share, whether we agree with whether you should write your tests first, or whether you should backfill them, whether you should have a loop that runs in milliseconds, or whether you're OK with a loop that runs in seconds, or whatever. There's a large shared understanding of, oh, these things are good. You should be able to test the majority of your code by running a command, and then that takes x amount of time, and then that gives you confidence that you didn't break anything. Wonderful, right? So at the very least, TDD has given us all that. So it's given us a large body of shared values. And then we can sort of hackle about the things that stand on top of that and how we get to them. But yeah, that'll be my closing.

**Martin Fowler:** Well, I think that kind of summed it up fairly well. I think there's actually a lot of areas, as I suspected before we began
all this, a lot of areas of agreement between us. I mean, we value self-testing code a lot. We all think TDD is useful in some contexts. We might disagree on how many contexts we'd use it. Although actually, it's kind of hard to tell. If we all went into the same situations, how much variation would there actually be? Or is the variation due just because of the context that we're in? And we don't know that without actually having the chance to work together. I know that a lot of the kind of people who were thinking that Kent and David would be very opposed to each other, that would be wrong. Because I've worked with Kent, and I've talked a lot with David. And I know you've got a lot of very similar aesthetics when it comes to software development. So it doesn't surprise me. But in the end, it still boils down to the fact that if you're going to be involved in software development, you have to be thoughtful about it. You have to be building up what practice works for you and your team. You can't take any technique blindly. You have to try it out, use it, overuse it, find what works for you, and be thoughtful to how that is going to improve development. Because we're not in some kind of codified science. We are in a place where we have to work through our own experience. And on that note, I've enjoyed this discussion, found out a bit more about your thinking, which is what I like. And I've also found that this idea of
talking things over through some kind of video link like this is really quite a fun way to explore topics.

**Kent Beck:** Absolutely. Thank you very much, Mark. And thank you all for listening. And I hope people find this stuff useful over the next few months. So bye-bye.

**DHH:** All right. Thanks. Bye.
