**Martin Fowler:** When I was asked to give a keynote this time and I sent in the details of my talk, the title and the description, people were
a bit alarmed because they said, you spoke here two years ago with the same title and the same description. We don't want the same talk again. Of course, what they did not realize is that this is a very generic title. I can talk about anything with a title like this, and I do. And the way I give my talks now is that rather than giving you one long boring talk, I'm going to give you two short boring talks instead. And I have this little cluster of short 20-minute talks that I arrange for all of my various keynotes I give and I just say, oh, maybe do this and maybe do that, depending on the conference and my mood and all the rest of it. The two you're going to get today are, in fact, both completely new talks. I've not given them anywhere before, so forgive me when they all go completely wrong.

So, for the first talk, I'm going to talk about workflows of refactoring. And I started thinking about this from conversations with various of my colleagues and from various things I'd read on the internet, where I got a sense that people were not necessarily utilising
refactoring in as many ways as they could. A lot of times, people were set for certain particular circumstances when they might consider doing some refactoring, and missing out on other circumstances where I think it's valuable. So what I wanted to try to do was to capture and write down the various situations when it makes sense to do some refactoring. I've written this up as an info deck on my website, so you may have seen the content from that, but this is the first time I've given this as a full talk.

Now, for many, what seems to be the most common case that people talk about doing refactoring is in the context of the cycle of test-driven development. You've probably seen this many, many times, people talk about this cycle of red-green refactor. You begin by saying I want some new functionality, so I'm going to add a test, a failing test that turns my test suite red to indicate the beginning. And then I'm going to make that test pass by doing the work in order to add the functionality. This takes my test suite from red, failing, to green, successful. But while I do this, if I'm doing this in the appropriate test-driven development style, I don't really worry about making the code very nice. I try to get it working in the simplest, most straightforward way I can. I don't concern myself about how it fits in with the rest of the system. And then I take a third step to refactor, which is to say, okay, this new code that I've put in, now let's make it clean. Let's remove duplication with other parts of the system. Let's reassess how I factored the code, how it interrelates with the rest of the code that's there.

You might wonder, or many people might wonder, why do we separate out the two steps of writing the code, which is making it work and making it clean? Why do we think of those as two steps rather than one? This is particularly because, of course, beginners often tend to
leave out the second step. They don't tend to put enough attention into the refactoring. But even if you're good, why separate this out? Why do it in two bits? And I like to explain this by going back to an old metaphor that goes back to the very beginnings of when we talked about refactoring. It was a metaphor that Kent Beck told me, and it's the metaphor of the two hats. He said that when you're programming, you should be thinking of two distinctly different modes of work that you're operating in. One is the mode when you're adding
new functionality, making a test work, or, in any circumstance, not necessarily within test-driven development, you are thinking about
making the code do something it didn't do before, adding a new feature to it. And then you have a completely different mode when you're refactoring. In that mode, you aren't making the code do anything different. In fact, you want to preserve what it does and not make any changes to its outward behaviour, but you want to improve its internal structure. That is the essence of refactoring, and typically
done on top of a test suite that you're able to run regularly as you go, so that you're able to detect if you make any mistakes.

When you're refactoring, even if you're coming across a bug, you wouldn't fix it, because that would mean changing your behaviour. So what you do is the rule is that you can only wear one hat at a time, but you're allowed to frequently swap between the hats. So, if you
were refactoring, and you came across a bug that you wanted to fix, you would have to stop refactoring, switch back into your adding function mode, fix it, because that's when you're allowed to change the external behaviour, and then go back to refactoring again. You must always be conscious of what mode you're in. Now, these aren't the only two modes in which you operate when you're programming. There are others too. Performance improvement, for instance, is similar to refactoring in many ways, but you're focused on making your code
faster rather than making it more clear. So that's a different mode.

Another mode is when you're exploring, sketching out an idea, not really quite sure what you're going to do, and you're probably going
to throw it away when you're done. That's a kind of sketching hat. A friend of mine said that really should be a jaunty beret of some kind, perhaps. But I'm going to really just focus on these two modes, adding function and refactoring. Obviously, within the test-driven development cycle, that's the separation between these two parts where you're touching your production code. At the beginning stage, you're adding function. In the second stage, you add refactor. So why do we separate these so much? It really comes down to the way in which the attitude and the mode that you're working. When you're refactoring, you're always operating on this basis of I'm never going to change the behavior. I'm going to take small steps. I'm going to run tests every time. Any change causes me to back out. If I make a
mistake, I undo what I just did and then try it again, preferably with smaller steps. That rhythm is very different to the rhythm when
you're saying I want to induce some new behavior into the program. As you work with this, you get used to that two different styles.

Now, this style of refactoring, refactoring in this context of test-driven development, I think of one of the potential workflows of refactoring, what I refer to as TDD refactoring because it's within test-driven development. As I said, it seems to be the most common one that people think about because they're often taught about refactoring in the context or together with test-driven development. Let's look at a couple of other potential cases. So you probably all had this situation. You're looking at some existing code. It's probably somebody else's, but if you're a good programmer, it's probably your own, and you've said, oh, my God, that's awful code. What was I thinking? What was that idiot thinking? Which is me, of course. Why is this? This is doing something completely the wrong way.

And a lot of the time, certainly in my younger days, the thing that was said was, well, you know, if the code works, if it's doing what it's doing, you don't want to go and change it. You want to leave it as it is because, hey, it's working. If you touch it, you might break it. The refactoring mindset says that when you see something yucky, you actually should go in and fix it. You should say, I see a
mess. I immediately have got to do something to make it cleaner. In fact, refactoring is very much part of that cycle. You're always working through, you see some piece of code, you say, that's not right, and then you go in and you immediately do something about it. This is how you fight back against the entropy of software's design gradually falling apart over time. You have to have a conscious counterforce, and one of those counterforces is an intolerance for stuff that is just not working right. It may have been fine two months ago when you wrote it, but now you realise it's not right and you have to change it and you have to fix it.

I think of this as a very opportunistic form of refactoring, and it may not be on the code that you're actually working on at the time. Sometimes, you do this kind of thing when you're looking to use some code that's already been written, it's already separated out to some degree from the code you're working on, and you look at this and you say, no, this is just not looking right at all. The thing to do is to go and fix it, not let it sit and stagnate and fester. I think of this as litter pick-up refactoring because you're cleaning up. You may have heard it sometimes expressed as the Boy Scout rule. Always leave somewhere cleaner than it was before. Now, it doesn't necessarily mean you've got to completely clean it up. There's a judgment here about how much refactoring is appropriate depending on all the various other things you've got to do. I think you should always try to make it at least a little bit better. At least a small improvement. Then, if it's code that you're regularly hitting, over time, multiple small improvements will make it really quite nice. On
the other hand, if it's not something you hit very often, then you don't want to spend a huge amount of time on it. You don't necessarily want to completely clean it up, but you do want to remove the worst features and make it a little bit better for the next time through. That's where I think the Boy Scout metaphor comes through quite nicely.

Now, there's a very closely related version to this, which is when you're looking at some code that you don't understand. You look at it and you think, what on earth is this bit of code doing? You have to puzzle it out. You have to think it through and say, that's going there, this is doing this, that's connecting to that, and that's kind of doing that. Where is it all fitting together? At some point,
of course, you'll figure it out, hopefully. You'll say, oh, that's what's happening. That is a very important moment. That moment when
you go, oh, that's what's going on here. Because the wrong thing to do at that point is to say, okay, I understand it now, carry on doing what I was doing before.

Because the problem is, as Ward Cunningham put it so well, that moment, the understanding you have of the code is in your head. But it's fragile in there. I mean, you're likely to forget it, and the rest of your team isn't going to share that understanding. So what you
need to do is to move it out of your head and put it into the code itself by refactoring it, by going in and making it so that it's as
clear and obvious as you can, and that next time that you or somebody else goes through that bit of code, you haven't got to spend time figuring out how it works. Figuring out how something complicated and not easy to see works, that's a good thing in a detective novel. It's a bad thing in code. So make sure that you go and you clean that stuff up. And again, I'm giving that a name. I think of that as
comprehension refactoring.

Now, comprehension refactoring and little pickup refactoring are very similar things. You could argue they're really the same thing, because any code that's hard to understand is almost by definition yuck. But I tend to think of them as slightly different triggers. In one case, you're kind of seeing something ugly. In the other case, you're seeing something that's hard to understand. They're slightly different things that are leading you into it. But they both require the same reaction. Now, there's a bit of subtlety to the reaction.
I like to think of it as there's kind of two tracks that you want to consider. Whenever you see something that you don't understand or
is just plain yucky, the first thing you have to ask yourself is, do I want to fix it now? Now, you may have seen it in the moment of some other refactoring that you're doing. You may have been seeing it in the moment of adding a new feature. And the first thing you have to ask yourself is, is it a quick, simple fix that I can do right away without impending what I'm doing? Or is fixing it going to take a bit of time? It may be just something like renaming a method that you can do in your IDE. It's just punch, click, bump, there you are, in which case, just do it right away, which you can do that. Otherwise, you might have to think about it a bit.

If you are working on adding a new feature, and as a result, you're in a red code base, you've got some failing tests, if you want to fix it immediately, the first thing you've got to do is you've got to get onto a green test base. There's various ways you might do that. You might, for instance, you might disable the tests that you're currently working on to make sure that the rest of your test base is okay, and then you begin the actual refactoring, and then, when you've done, you re-enable the tests that you're working on, and you get back to your regular work. If you can't do it straight away, the thing to do is to immediately make a note.

Some people like to have some index cards, or a spare Emacs buffer, make a note, I've got to fix this right away, put that to one side, and then as soon as you've finished adding the feature that you're doing on, you go back and you make that little bit of clean-up. It
is really important that you treat refactoring as an integral part of your regular work. As soon as refactoring becomes a separate task, then it becomes a big discussion and a big argument as to whether you should do it. Instead, the easiest way to go is to just make sure that you're always doing the appropriate amount of refactoring as you're doing your regular work.

Another trigger for refactoring is when you look at some code and you realise, I've now got a new insight about how the code could work that I didn't have before, particularly in the context of some new functionality that I now want to add. It would have been really, you've often had the situation, I imagine, where you look at some code and you say, I've got some new functionality to put in, and it would be really easy to slip this functionality in if only the code was organised slightly differently to the way it is, and you feel frustrated that you didn't foresee in the past what you now needed to do now. It is that frustration that led a lot of people to very intense upfront design, trying to think through all the design issues at the beginning so that you don't get those moments. If, like me, you're a fan of more evolutionary approach to design, you get these moments all the time. You look at your code and you say, well, that was okay, it was the correct thing to do yesterday, but now I've got to add this new functionality, it's not looking right any more.

This situation also calls for refactoring, what I think of as preparatory refactoring. It basically says that if you're in a situation
where you've not got a good fit for what you want to add, you want to first begin by refactoring it into the shape that now is obvious
is the shape that you want it to be in. Do that in purely refactoring mode, with your refactoring hat on, your tests are green, you should be able to produce that transformation quite quickly, and then, once you're done, then slip the new functionality in on your now better refactored code base. A lot of people complain about refactoring taking time away from other things and slowing you down, which, as I'll point out in a moment, is definitely not the case, but usually, the benefits you get from refactoring are in the medium term. This is a case where you can get that benefit actually in the middle of a task you're doing. It often can be faster to do a bit of preparatory refactoring and then add the new functionality than it is to try and get the new functionality in with the code not really quite
fitting it, even if you don't refactor the clean-up later on, which you ought to be doing anyway. So, whenever you get that feeling of, well, if the code was better organised in a different way, stop and refactor, get it in that shape, and then bring in your new change.

So, those refactoring workflows that I just talked about, the little pick-up, the comprehension, the preparatory, these are three refactoring workflows that I feel aren't used widely enough. The next one is one that is clearly used a lot because I often get questions about it, and that is what to do about refactoring as part of your project plan. This is when a significant amount of cruft is built up in the code base that you actually want to mark it on your project plan as something that needs to be cleaned up. I think of this as a planned refactoring because it's something that's very visible as part of your tasks. My view is that a good team should hardly ever have to do planned refactoring. In fact, a perfect team would never do it at all. Not because they're not refactoring, because a team is always refactoring, but they're able to break it down into the smaller pieces. It disappears inside the work of adding new functionality, and therefore never becomes a line item on the plan. Most teams, however, take a while to get to that point, and as a result, some planned refactoring has to be done. But the problem with planned refactoring is it is always an exercise to justify, and that's why I try to avoid it. I try to do little bits all the time as part of the regular work. I see that, as software developers, our responsibility
is to keep the code base clean, and I will expand a little bit on that later on. But planned refactoring I see as a kind of necessary evil, and if you're doing it, then that's a smell that you're not doing enough of the other kinds of refactoring.

Now, this, of course, presumes, all of this kind of presumes something, which is it kind of assumes that you have refactoring tasks that you can always complete in a relatively short period of time. But, as you work on a code base over time, larger things will become apparent. You might say to yourself, well, I've got a bunch of modules with a lot of messy dependencies. Maybe they just developed over time and you didn't pay enough attention to keeping them steady. Maybe you're inheriting a code base from somebody else, and they didn't pay enough attention to these. How do you clean things up in this kind of situation? How do you do a long-term refactoring? My advice
here is really very much using the workflows I talked about earlier on, and preferably not the planned refactoring workflow.

What you need to do is get some vision of where you'd like your code base to be. I've seen this done in a session the team might spend
an hour or two in a design meeting saying, this is how we'd like things to be in the future. This is our goal, our long-term goal. But
rather than set up some tasks in your plan to get to that goal, you say, okay, from now on, every time you're working through this area of the code base, refactor it a little bit to get it a touch closer to that goal. Then over the course of several weeks, maybe several months, you kind of inch your way there a little bit at a time. Gradually one dependency gets broken, another one gets done, until the final step can be done as a relatively short piece. That gradually inching towards a goal, I find it preferable because for a start it doesn't get into the whole planning refactoring steps in a plan, but it also allows you to learn from the process of reaching the goal itself and keeping the code stable and clean and always ready to deploy in a good continuous delivery environment as well. You can actually surprisingly achieve quite large refactorings by doing them in this very small, gradual, step-by-step way.

The key, I think, to good refactoring is to remember the essence of it is small steps. How can you break down a change into the smallest possible changes? Even a big change can be broken down into little steps. It may not seem very easy at first to figure out how to do
that, and that's another reason why doing these small steps can be handy. If you lay out the goal and you say, I'm not quite sure how we're going to get there, but let's at least try and push in that direction and exchange with each other ideas we have of how to reach it. Sometimes it may take a bit of time before you begin to see the path, but by gradually making progress there, sometimes that clears
the mess out of the way enough that you can see your path forwards.

All of this has been about how to refactor, but I need to finish by talking a little about how and why. A question that often comes up
is, is refactoring effectively just wasteful rework? In fact, for a long time in my early days, that's how people saw any changes like
this of existing code. It was just reworking stuff. It was an indication that you'd failed. It was waste. The reason that I feel that refactoring is important comes down to something that I refer to as the design stamina hypothesis, a long, complicated phrase that sounds like one of these German words. It basically says that if you don't pay attention to design on your system, over time, as you continue to develop, it seems like you're steadily slowing down until you reach a point where you seem to have any new functionality takes ages because the code is fighting you.

How many people have worked on projects where they had that situation? Everything's slowing down and the code is fighting you. Yes, pretty much everybody. If you pay attention to good design, however, you can hit another curve. In this curve, adding new functionality becomes really easy because you've got all of these nice modules and all you've got to do is combine the modules together in a slightly different configuration and you've suddenly got some awesome new functionality. You feel that you've got your code base is now this wonderful collection of components that you can quickly configure to add new things. How many have worked in a code base like that? A few.
Usually a lot less, but there's always some.

What you want is that better design curve. Refactoring is the key to be able to reach that better design curve. I mean, you could do it by coming up with a really wonderful design in advance, but I've hardly ever seen anyone succeed with that. What refactoring does is it constantly keeps your code base in a good state, always pushing you towards that good side of the line. If you're diligent about doing that, that allows you to get onto that good curve. What does that mean? It means that you're able to deliver more functionality more
quickly than somebody who has got an ill-designed code base, and that's the essence of why refactoring matters.

When I hear people talking about refactoring, they often say, well, why should we refactor? Well, it's because we want a good quality code base. We want it to be clean. We're professionals. We don't want to leave a mess. We want to do the right thing. And I hear teams frustrated because they say, well, our managers won't let us refactor. We've told them that we need to do this. It's the right thing to
do. And they say, well, maybe later we'll do it, but not now. The trouble is, as soon as you talk about refactoring or attention to good design and modularity in terms of professionalism and keeping your code clean and all that kind of stuff, you've lost. As soon as you try to make this argument, you're screwed. This argument you want to ignore. Get rid of it. Instead, focus your argument on simple economics.

We're doing this in order to be able to deliver more functionality more quickly. That's the only reason you should be refactoring. And
you should think about that in terms of your own refactoring. Is this refactoring I'm going to do, is it going to make a difference? Is it going to help me go faster in the longer term? And there are times when it tells you not to refactor. If you're looking at an area
of your code base which nobody ever touches and it does work, but people don't ever go into it, they don't need to make changes to it,
then you can leave it messy because it's not slowing you down. But when you're constantly feeling, oh, I'm slowed down by the code here, I could go so much faster if the code was cleaner, that is a sign that says you've got to work on refactoring that area of the code.

And it's very agreed, it's very hard to justify this to management because if they're not in the code base, they can't see it. But my argument is a somewhat controversial one. You shouldn't actually tell them. It's part of your professional responsibility as a programmer to keep your code base clean. Only those in the code base can assess whether it's slowing you down or speeding you up and what it seems to get onto that good curve from the bad curve. And it is your job to do that because if you're not doing it, you're effectively stealing from your customer. You're making them spend more money, take more time for the same functionality than they would have done had
you been paying attention to the economics of how you work. So remember, refactoring is about an economic argument. Clean code allows you to go faster. That's the only justification behind it. And on that note, hence I finish my first talk.
