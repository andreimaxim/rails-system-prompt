DHH: Hey everyone, welcome to Unwriting Software, Unwriting Software, well, I don't know, I don't know what this is going to be called yet. What I do know is I wanted to have an opportunity to talk about software and writing it, specifically looking at code while we do it, not just as an abstract form of discussion, not really in a way of trying to show you a specific library or whatever, just the considerations that I encounter as I'm writing code, predominantly for Basecamp, sometimes for Rails, we'll see where it goes. I just wanted to have basically a chat with the camera as though I was sitting and having a conversation with another programmer and we were discussing how can we make this piece of code better, how can we make it clearer, easier to understand, all these good things that we're considering when we're writing software. So, the first thing I want to open up with and talk about today is the idea of code commons. Code commons, I have a sort of mixed relationship with that. Sometimes it's really great that you can have a chance to explain something that does not seem obvious from the code, but more often than not I tend to look at code commons as a bit of a smell. Why are you explaining something that isn't apparent or clear from the code itself? If you're writing in a programming language like Ruby, you should be able to encapsulate whatever it is you want to explain in the code itself, such that this does not need additional explanation in prose. Now, here's a piece of code we have in Basecamp 3. This is an encapsulation of the access concept. People have access to what we call buckets, which is this abstraction that covers teams and projects and circles and stuff like that. And this access object basically is what we check for when we check whether a person has access to view a piece of content. Now, the access itself, when it's just up and running, basically has too many relationships. Buckets can have many people accessing them and an individual person can have access to multiple buckets. But when the access is revoked, that's when something interesting actually happens. We need to do two specific things in Basecamp. We need to reconnect the user from the action cable server. That's the thing we use to manage the WebSockets connection that we're sending updates over. Basically, you shouldn't get updates from channels that relate to buckets that you no longer have access to. So what we do is we check whether the person, first of all, is a user. We have a few different ways of dealing with persons in Basecamp. One of them is that someone is a user where they can log into the system. Another version is with their client where they can't log into the system. And a third is actually that they're a tombstone, that they've been deleted. And then, of course, they can't log into the system either. But that's one thing we need to do. But what I really want to focus on today is this remove inaccessible records method. Because, as you can see, it is the only method in this class that has code comments. And I was just reading through the Basecamp code. I started doing a new branch yesterday that I call DHH Refactoring 2018. As I frequently do, I read through the entire code base of Basecamp 3. And try to make things better that I don't think are good enough. Or basically revisit decisions that we've made earlier that I think now I have a better idea of how to do. And the first file I opened was this access document. As you can see, it's literally the first model in our directory. So I thought, why not start there? And the first thing I really just noticed was this comment, right? When we're removing inaccessible records, we give you basically 30 seconds of grace period to undo that. When we remove all the inaccessible records, it's kind of a job that takes a while to run. That's why we run it in a job in the first place. And it's also irreversible. All these records that need to be removed, when they're removed, it's kind of a pain in the ass to add them back in. Let's actually just take a really quick look at that inaccessible records job. Here we go. So it removes a bunch of things. We have these things called readings, which is a recording of whether someone had read a piece of content in the system. We have bookmarkings. We have a bunch of things. It doesn't really matter so much. What matters is that these things need to disappear when someone loses access to a bucket. But the nice thing we came up with here was that sometimes you accidentally end up removing someone. And if you add them back in 30 seconds, we won't actually have destroyed all these records. And it's kind of just a way of offering an undo. In any case, I didn't like this comment here. I felt like, why do we need a comment to explain this concept of forgiveness when we could explain it in code? And the first thing I thought about here was, what is this actually explaining? It's not explaining this conditional. It's actually explaining this somewhat magical integer here. In Ruby, we have this... Well, actually, in Rails, I suppose, it's an active support addition that you can say 30.seconds to explain what this 30 actually means. It actually just returns 30, right? But we could have written 30 minutes, and then it would have returned 30 times 60. Well, we have our 30 seconds here, but it's still a bit of a magic variable. Because what are these 30 seconds? Well, that's what we explain up here, right? It's 37 seconds of forgiveness. Couldn't we just explain that some other way? Well, the standard way is, of course, to extract an explaining variable. So we could just do it inline. We could do grace period for removing inaccessible records. Right? 30 seconds. And then replace the concrete use that's down here with this explaining variable. Great. All right, this is actually a step forward already. We could just delete this, and that looks better. That's not bad. I tend to see these inline declarations of variables as another sort of smell, right? Like, this is not actually something that needs to happen every single time we run this method, because it never changes. It's a constant, in fact, right? Okay, great, constant. Let's extract that constant and see what we can do with that. We could take the constant here, and we could... What we normally do, what I normally do, is I just shove it right up here, and then I think TextMate has this way of tackling the case. There we go. All right, great. We have a constant up here. We can then use the same constant down here. We're referencing it. That's an improvement, too, right? This is getting better. There's something else, though, I find when I extract these constants, is how far away are they from their usage? And is this a general constant that someone should consider as a public constant, or is it more of a private thing? In this case, I think it's actually more of a private thing. We're not going to need to refer to this constant directly somewhere else, so we don't actually need to have it declared publicly. So we could remove this, put it down on the private. Okay, even better still. It's closer, but it's not really fully close enough to the method that we're using. So let's swap the order of these two methods, and now it's pretty good, I'd say. You have the method that references this constant right next to where the constant is declared, so you read them sort of together. That introduces sort of a separate problem here, is I love to have my private methods in basically order of contents, table of contents is what I call it. And the table of contents is declared by when they're called. And we're declaring them when we're called through a couple of callbacks here. We have after destroy that does the reconnection of the user, and then we have the after destroy commit that once the access is destroyed and that transaction is committed, then we remove the records from it. So they're not really in the right order here. Reconnect is called first, so it should be first. But if we just took basically this block and moved it down here, that sort of works. But then we have this constant floating here in midair, which doesn't really seem that aesthetically pleasing to me either. I like it when it's just indented straight on the scope, the private scope. And this is sort of what I'm talking about. Like these are the considerations where you have a general principle that you want your private methods to appear in the order of which they're called, the table of contents. And then that conflicts with another aesthetic consideration that you want your constant to be declared first, and you want them to be declared as close to the usage of that constant as possible. So when you have these two considerations that are somewhat in conflict, you have to choose which one is more important to you. And in this particular case, I think that it's actually more important to have this look good and then violate the idea of the table of contents, especially since we just have these two methods here. It's a good example too of where if you just had an automatic style checker, it can't really encapsulate and deal with this. And what we're trying to do and what I'm trying to do basically is just make this easier for me to read, more aesthetically pleasing for me to read, easier to come back to. Yeah, so that's basically the considerations that went into just extracting one simple constant because we didn't like the, or I didn't like the use of a code comment. And that's it. The second thing I wanted to talk about today is basically how I go about extracting things into Rails. A lot of that comes from reading through the code base, as I said, this mission I'm on right now, reading through the entire Basecamp 3 code base and finding things that would be well-suited to go into Ruby and Rails. And the thing I stumbled upon here is this block, the grant person administratorship. So administratorship is basically a joint model, again, between an account and a person and who has the right to administer that account, who has the right to grant other people access to things and remove people and add people to the account and all the stuff that you normally allow admins to do. Well, we've encapsulated that in the idea of an administratorship rather than just having an admin Boolean or something else like this. I really like encapsulating these domain objects and being able to reason about them and giving them a place to live and giving them a whole concept rather than just giving them a Boolean. And in any case, here we have an administratorship association, a Haas mini-association. But we want to do something a little nicer on the DSL side of things when you want to give people an administratorship or revoke it. And in the grant method here, you see what we're basically doing is we're adding methods onto the association. So it'll be account.administratorships.grant and then you pass it a person. Now, an administratorship, you only need one. So if a person already has one, we shouldn't allow them to create another record in the database. That just can confuse things. So first of all, we have a unique index on this pair between the account and the person in the regression that we set up for the administratorship. But we also want to basically deal with that if it pops up in the code. If somehow someone triggers or tries to grant an administratorship that already has been granted and we catch that. Well, you see it's a little odd here, right? So we're actually using exceptions as a control flow. And what this block of code really wants to be is something much shorter than this, right? It shouldn't be all these lines. It shouldn't have this code comment as we just talked about in the session before this. Code comments are a bit of a smell. The fact that we need to explain what's going on means that it's not quite obvious what's going on. Well, what's going on is that Rails has a default method basically called find or create by some pair of attributes. This will be person, person. But Rails does this in a sort of way that encourages people to get stale reads if they have a really busy application. Because find or create will start a transaction. Then it will try to do a where call in the association for a person, see if there's already an administratorship between the account we're currently on and the person we're passing in. And if so, just return that. Otherwise, create something. Well, those two separate steps, of course, are separate steps. And now you're liable to end up with a stale read. And on an application like Basecam that has a fair amount of usage, this certainly can happen. And there's just a better way of doing it. And the better way of doing it is to basically try to create this administratorship association up front. And if it does not work, well, that means that it already happened, right? So we're basically just doing one insert and relying on the unique index in the database to throw an exception if this person already exists. And then just return that record we're looking for. We didn't have that, or we don't have that right now. So it needs all of this, right? What we want, really, is we want something like what we have in Rails right now. We just want it flipped. We want create or find by person, person, well, person. And in that, we're going to encapsulate this whole pattern of doing the create, catching the exception, and just returning the person that's already in the database if that happens. And then if we have that, we can reduce this whole thing to basically an alias. Grant becomes an alias just to create or find by person, makes the DSL just slightly bit nicer, and there we go. So this is one of those things I'm looking to extract, just a small extension to Rails, put it into Rails, and then we'll have this pattern go forward. In fact, perhaps this pattern should be the default, and we should consider whether we want to deprecate the find or create by signature instead. Just one other thing I'm noticing here is, I don't know how we ended up with this, but where actually can just deal with records directly, it doesn't need to deal with just IDs. So let's fix that zip time, and there we go. That's pretty much it.
