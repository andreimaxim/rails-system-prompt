DHH: Hey, this is David Heinemeier Hansson. Welcome to episode 5 of Unwriting Software Well. Today I'm going to show how we do testing in Basecamp. We're going to focus on two specific aspects, model testing and controller testing. But before we get into that and I'm going to show a specific feature and how we do all the tests around that, I just want to set the stage a little bit. I've talked a fair bit about testing over the years. A couple years back I had a conversation with Kent Beck and Martin Fowler following a conversation or keynote at RailsConf, the title something along the lines of TDD is dead. And that keynote and the following conversation sometimes get misconstrued as though I don't like testing, we don't do testing at Basecamp or other nonsense like that. Which is, yeah, nonsense. Because we do a lot of testing at Basecamp. We write, we have tens of thousands of written lines of test code. I do not feel comfortable in any way, shape or form shipping new features without us having a suitable amount of automated testing. Where my criticism in the past has come in around TDD and other testing techniques have been what they do to the code itself. What happens when you subject model code or controller code to stringent requirements offered up by testing, such as the idea of unit testing, that you're testing a single thing in total isolation and no other side effects and no other interactions are supposed to happen. And all that stuff is to be stubbed out in the name of speedy tests. Well, I don't think that's a good trade. We talk a lot about tradeoffs on this channel and the tradeoff between having super duper mega fast tests where you can perhaps run hundreds of tests in just a few seconds versus having to serve as a cadre of mocks and stubs and other forms of dummy methods or dummy objects to be able to do that. I don't think it's a good trade. I think in the majority of cases, you're better off testing the real things, interfacing with the real database, interfacing with the real generation of HTML and controller. These things that are somewhat slow, but can be mitigated through a bunch of different factors and can be made fast enough. The purpose of developing software is not to have fast tests. The purpose of testing your software is to have high confidence that the features that you're shipping are of high quality and that they don't break, at least amongst the common paths that programmers are likely to test down. I think there's a whole other episode we could do around QA, especially exploratory testings done by humans, humans that were not part of the development process, and I see great value in that as well. In any case, I'll link to a couple of position pieces on testing and TDD in particular in the show notes, but with that said, let's get started. Let's look at how we test a specific feature in Basecamp using concerns and all this other stuff we've been talking about in previous episodes. So the feature we're going to look at today is really two features. It is the documents feature and it's the aspect of documents that they can be locked such that only one user in the system can edit them at the time. The locking aspect of documents comes to us through a generic consideration that flows through the recordings object. Recordings is this base object in Basecamp 3 that provides a lot of the shared behavior that multiple types of content in the system can use, and documents is one of the types in the system that can use this lockable concern. As you can see, the document class here doesn't really have a lot in it, right? It's mostly a container just for the data, not so much about the behavior because a lot of the behavior in the system is held in the recordings class because it's shared by multiple different types of content. For example, the fact that you can lock a document could then also be a feature that you can lock a to-do list or something else to prevent concurrent access. In any case, as you can see here, we are explaining a couple of things. The fact that documents have rich and plain text attributes, this is something that ties into our content system. The fact that we use a rich text editor called Trix to provide uploads and formatting and all these things. So that's really sort of inherent to the document, that these are attributes on the document class. These are generic things. Not everything has a content, not everything has a title, but documents do. So this is where we declare that. We also declare the fact that there is a default title called untitled and we use this neat little trick of calling super because document is, of course, an active record base. These days, if you had started a new application, it would have been application record in Rails, but we predate that and haven't updated it since. Then we have these three different predicate methods, auto-positioning, subscribable and exportable that provide the recording features a way to interrogate the recordable of which document is one and ask whether they're capable of doing this stuff that they're doing. Just as an aside, this isn't really what we're going to be talking about, but I just wanted to show that, for example, the fact that a document is subscribable means that users in the system can subscribe to a document to get comments, updates and changes and so on from it. I just wanted to show this subscribable concern that we have on recordings and I just wanted to show the delegation here. The fact that we only subscribe the creator, for example, to a recording if we say that the recordable is subscribable. This is a way of disconnecting generic concerns of which subscribable is one from the specific content types such as document and whether a document is able to be subscribable or not. We don't have to maintain a master list of types here that can be subscribable, we sort of flip that around and let the document answer whether it's subscribable or not. In any case, let's have a look at the lockable concern, which is this other thing we're going to test here, the actual piece of behavior. It comes to us through the recording, as I just said. The recording is this base type that provides a ton of behavior to all the different content types that we have in Basecamp, whether it's a document or a to-do list or a file upload or whatever. The concern we're going to talk about is the lockable concern. That's one out of this long list of all sorts of things that recordings can do. They can be moved, they can be mentioned, they can notify, they can be published, they can be a bunch of things, a bunch of behaviors that are generic, applying to multiple recordable types. The lockable concern is really quite simple. It just basically maintains a little bit of nicety of DSL around the fact that there's an association here that a recording can have a lock, and a lock can be owned by a given user. When you try to lock a recording, lock a document, then we first check whether it was already locked and we can query whether it's locked by the same user. That's basically the feature here. Let me actually show you how that looks in the app itself. If we go over here and take a look at the app, on the left-hand side I have Victor locked in and on the right-hand side I have a private session which is basically just a way of getting another cookie domain such that I can be locked in as two different people at the same time. This is Cheryl. If Victor goes here and says he wants to edit this document, well, he'll be let in right away because there's no one already editing this, so he gets access right away. If Cheryl, on the other hand, goes to try to edit the document at the same time as Victor is editing, well, she's going to get this screen. This document is locked, well, Victor Cooper makes edits, blah, blah, blah. You want to break the lock, but you want to never mind, not bother with it. That's basically the feature we're trying to expose here. But before we get to that, let's have a quick look at just the simple tests that we do around a document alone, not considering the lockable concern. You'll notice a bunch of things I'll call out here. One is the fact that as a setup method, the only thing we do is to set who the current person is. We talked about this concept of current globals in another episode, you can go back and look at that in the playlist. We set that up such that whatever is being done, interacted with the system here, all those actions would be recorded as me being the creator or editor or whatever. And then what you'll notice is that there's no factory methods here. We use the stock vanilla Rails idea of fixtures, and fixtures is this wonderful concept of where you basically configure a base set of characters in a world that you can pull upon whenever you want to play a certain part. These are sort of just defaults that can be used in all sorts of different forms of testing without the particulars that correspond to that specific test. For example, we have a bucket, which is this generic concept that's used for teams or for projects. In this case, it's a project, an anniversary project. It's just a standard project. When we need to test something that needs to interact with the project, we don't need to first go through the trouble of setting that up. We just plug out a fixture for that and start using it. So that's what we're doing in this simple test. It basically records a new document onto the bucket, which gives us a recording back, and that recording has the correlation to our recordable, which is the document itself. And we just do a few simple asserts on that, that these values we've set go all the way through. This next test is a little bit more interesting. Documents have this feature of having their previous versions stick around. When you record a new document towards a bucket, you get a recording, but if you update that recording, we still keep the old version of the document around. I promised a few times that I was going to talk about our unique setup of buckets and recordings in a future episode, and I swear that episode is going to come soon, because I think a lot of the examples that I go through in Basecamp will make more sense once you sort of have that connection. But for now, just know the fact that recordables, such as documents, are immutable, versus recordings are mutable. So recording is sort of the current version, and that will point to the most recent immutable document, and then it'll still keep a record of the past versions, the past recordable versions, as we test here in the past. So this test is basically just showing that when you make an update, we can still have access to the past versions of these recordables. First we test that the first version of the recordables is that latest update that we made, new order, is what we updated here. But then also that the previous document, the second version, is what it was up here. One curious little funky thing here is we do this travel five seconds. Why do we travel five seconds? We do it because recordable versions are ordered by created at times. So if these were created at the same times, the system would kind of get a bit confused. That's never going to happen in real life. What is going to happen is you post a document and you edit it at least a second later. So this is a fine way of doing that. What you will also notice here is that these are not unit tests in the classical pure sense because we are not stopping anything out. These things all go through the database. When we're recording this new document, it goes through the database, it creates all sorts of stuff in the database. There's a bunch of callbacks actually that happens in other concerns and we just let those run. It doesn't really matter because it's really, first of all, it's fast enough. I think it's better, as we talked about in the introduction, that you're testing the real thing. That you're mocking and stopping as little as possible as you can get away with such that your tests remain as close to the metal, as close to the real thing as I said, and as readable as possible, that they don't have all this auxiliary complexity of setting things up that aren't necessary for the test itself. That's also the reason why I like this idea of fixtures, that you have a base world that you can interact with and then you can do specific things like here, the new documents that we're recording for the testing the versions feature, they're not fixtures because there's something new and there's something particular to testing this feature. That's documents. Let's actually just run that test. Let's go over here and see the document test and just run that because I want to show one thing is it actually runs pretty quick. This is not that slow of a test. It's not as fast perhaps as it could be. These four tests run in two seconds, so that's half a second a test. When you have hundreds and hundreds of tests, that's going to take some time. There are ways you can get down to 100 milliseconds less per test, but for me, that's not worth the trade-off. Part of this is coming because we use this thing called the spring preloader, which keeps a persistent process for your Rails application running in the background that you can test against. It doesn't have to spin up and evaluate and instantiate an entirely new Rails environment with your application loaded every single time you run through tests. It's pretty quick. But let's go back and look at the concern and testing that concern. What we wanted to test was this idea of locking. First of all, you'll see that the document test just lives over here under test models. Here's the document test right here. Then the lock test lives over under test models recording lock test. That's where we structure our tests. The lock test is similar in many ways to the document test. It sets up first the current person who's going to do all these interactions. Then it also refers to fixtures in the same way. It also doesn't care anything about all these other concerns that are present on a recording, as you see. We have a lot of different concerns. It just doesn't matter. It's allowed to run as they please. And again, this might slow things down a little bit. But hey, look at this. This is a pretty long list of stuff that a recording is capable of doing. It doesn't matter that all that stuff is there, is accessible, and in some cases adds callbacks and so on and so forth, because we just focus on this one aspect. We just focus on the locks when we want to test locking. It's really not that complicated. As you can see with these locking tests, there's just basically a handful of them, and they're trying to test this very simple behavior, which really is just a nice wrapping of the DSL around this axis of the single association of the lock. But nonetheless, same story, straight usage of fixtures, straight uses of these models, straight uses such as this, consideration for the lockable concern and for nothing else, really. And if I go back over and take a stab at running those, you'll see that that also actually runs pretty fast. Again, we have four tests that run in a second and a half. Granted, this is a relatively fast computer, but you're not going to get that different results. These are all currently at least single-core tests. So you only get to use single-core on them. That's changing in Rails 6, by the way, just had an announcement about that. We're going to do a paralyzed execution of tests, not that you really need it for this case, but when you run a larger suite, that can kind of make sense. So that's the model. We have our document. We have our lockable concern that's applied through the recordings generic object to documents, and we've tested both of those things. We found that those tests run pretty quick, that they're easy to write. Something else you'll notice here is most of the assertions that we write are extremely simple. I basically prefer to use only two different assertions. I use assert and I use assert equal, and I can make everything pretty much happen within that. There are cases where we extract domain-specific assertions if they need a lot of setup or complicated things to test, but in terms of the stock set of assertions, when it comes to model testing at least, I prefer to stick it just to these two. Let's look at the controllers, how controller testing works, how controllers work with this specific feature. We can start with the document controller, which is the way we create these document recordables. Let's just focus on one method here, the create method. As you can see, we're recording a new document on the bucket, and the bucket is then giving us a recording back. That is almost identical to the test we ran here in the document test. That's what's happening in the controller as well, and then we redirect to either edit subscriptions or recordable URL. This is this concept of sometimes you want to be prodded right after you record a new document as to who should be alerted about this document, or should we go straight to the recordable? Really not relevant for this discussion here. The way the tests for this work is even more integrated, actually. Let's use that word. Controllers are even further away from this idea of being a unit test, where we just test a controller and nothing else. You could just test this create action, and you could stop out everything, and you could make that controller test run really fast. It wouldn't test a whole lot, it wouldn't test whether the pieces actually work together, but it would run fast. I prefer to have them to be more comprehensive, even if that means that they're slower. Let's look at this notion of testing the creation of a new document. The first thing I test is actually not the create action, it's the new action, which on the controller side of things doesn't really do much. It just assigns this instant variable to a new document, but what it does is on the view side of things, it renders a ton of things. It renders the application layout, it renders the specific show template, and that stuff involves a bunch of different things that I really want to know whether they're working or not. Before I'm creating the document, I'm asserting that the form that we're using to create that document also works. That does take some time, as I'll show you in a second. These tests do run slower, because not only do they render the whole view, they also actually compile all the assets that we need to present that view, so that we can see whether everything is working or not. So we compile all the JavaScript stuff, and the CSS, and so forth, so that we get the entire view. This is really not lying when I say that this inherence from an integration test. This is a kind of integration testing. It's stopping just short of using the browser to drive the interaction, because using the browser to drive the interaction adds sort of an order of magnitude of delay to it. I think it's still a great thing to do when you need to test JavaScript behavior that you can't test this way. Here we're basically just dealing with HTTP requests and responses, and interrogating the HTML that we get back. We can do that all programmatically without involving an actual real browser, and when you can, I think that's a good idea, and it's a fair trade-off. Yes, you could have written a real integration test here that ran through a browser, but it would be overkill, because we're not really in need of testing any JavaScript-specific logic. In any case, here we just assert that we're getting a proper response back that means a 200, and then we have a customer assertion here, actually, as I mentioned before, where we test whether the breadcrumbs are correct. The breadcrumbs are, just so you can see what it is, it's this thing up here. And then we do basically the creation. We run through the creation, we post towards the controller with our full setup of everything we need, where does this document need to go, and who are the parents, blah, blah, blah. We then follow the redirect, because as you'll see here, the redirect is this thing, and then in this case, we're asserting that we end up on a page that's basically the new document, and the new document has an H1 that says, hello world. That's it. If we have a look, I just want to show you that this is definitely a different order of magnitude in terms of speed of running the tests here. This is slower, but I think it's a very worthy trade-off that the document controller tests a whole stack of integration, all the way from the HTTP request to writing to the database, and then, okay, we spend seven seconds to run 10 different tests, fair enough. The other thing you'll see here that might stand out to you is if you've read something on testing, some people subscribe to the idea that you should only have one assertion per test. I don't subscribe to that idea at all. I think you should have all the assertions that you need to feel comfortable about testing one aspect of what you're doing. In this case, the smallest thing we can test when we're testing a controller is a whole action, and we should test the whole thing. That ends up being three assertions for this specific test. Even with the model tests, as we were talking about before, in many cases, we have multiple assertions. Most of these have two, and this one, for example, had four. There's no upper ceiling here to how many you should have. You should be able to have as many assertions as you need to feel comfortable about having tested that one aspect in depth and in full. All right, let's have a look at the locks controller. The locks controller shows some of the power we have of this recordings, recordable pattern. The fact that we can implement a generic lock controller that could have worked not just for documents, but could have worked for to-do lists or any other piece of content in the system and acts on a generic way, it shows the power of using concerns through generic objects to apply them to concrete objects very nicely. As you can see, it's also a pretty simple controller. The whole interaction we're interested in here is this notion of being able to show if something is already locked and providing the ability to force unlock something that's already locked. If we go to the test of that, it goes through all these scenarios that we would want to test in that case. First, that there will be a lock if we've already locked this by someone else. So you can see here, we just lock a recording that we've fetched out of the list of fixtures that we have. Again, it doesn't really matter what this fixture is. We're just testing the locking feature on it. We assert that if you then access that document after it's been locked by Jason, remember who's accessing? It's David here. Here we have a slightly different way of setting up the current user, a setup method called sign-in-ask that sets up a few things, including current user that we're using for integration tests. But you'll just think through when you're reading through this thing. This is David accessing a page that was locked by Jason. And what it'll say is that this document is locked. Now if you're accessing your own page, it'll say that you're already locking this page. And then we test the redirects, if things are not locked and so forth. Here you'll also see there's several assertions per test, actually. I think the average here is, what, two? I mentioned these fixtures. Let me just show you that. So there are only four different documents that we use as the basic fixtures, and that's really all you need in most cases. This is a specific type of content, so we don't need that many. When we go to the recordings, which is basically every piece of content in the entire system has a corresponding recording, well, we have quite a few more. So when we're doing the lookups here as looking for the recording for introduction document, there's a few more of those, right? So we can go back here and see the introduction document, it belongs to a bucket, blah, blah, blah, blah. It's just all set up for us, so we don't have to do that busy work, and we don't have to read through that when we're reading through the tests. That's basically it, yeah. That's a testing setup for one generic feature as applied to a concrete class in Basecamp 3.
