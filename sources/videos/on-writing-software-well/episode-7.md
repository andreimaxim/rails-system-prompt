**DHH**: One of the hardest parts about writing software well is not necessarily coming up with the initial design, the initial architecture, but how to keep the purity of the cleanliness, the integrity of the design and the code going when you're making changes. Very little software stays just the way it is from the day it was written. Software has changed, and it's frequently changed a lot over a long period of time by different people who might not be privy to the initial implementation. It might be the same person who's simply forgotten how something should have been done, or it's simply not obvious when you encounter existing code how to change it. So I think one of the key aspects of writing better software is learning how to rewrite software, how to extend software, how to take a piece of code and make it better without ripping up every bit of the code base as it is. It's no good to be on a mission to write wonderful clean code if every single time you go to the code base you have to simply rewrite everything all over, right? So the mission that we have is, as part of writing software well, to make things a little better along the way, and at the very least not make them worse. So I thought I would take a look at an example from a pull request to Basecamp for a new feature or a new addition, a new tweak to the system that we just added, and go through the evolution of that pull request. I worked with one of our programmers, Tom, here on the pull request itself. I could just as well have written the software that Tom wrote originally to propose for this. So it's kind of just seeing sometimes things as an editor, as a reviewer, allows you to see things from a little bit of a distance, a little bit back, and then suddenly things seem obvious in a different way. But let's dig in. So the feature we wanted to add to Basecamp was the fact that we have these recurrent questions that will ask you, what did you work on today? Or what are you working on this week? Well, it so happens that some people end up answering these questions before we send them a reminder to answer that question. So if someone has already answered a question of what did you work on today, because they happen to end work at 3, and we've scheduled to send out the reminder at 4.30, it doesn't make a whole lot of sense to send out the reminder at 4.30 if they've already answered. So we should know that, right? The system seems dumb when it's asking you to answer something that you've already answered. So this seems like an innocent small change to the system, and there isn't a whole lot of moving pieces to it, but there are different ways of approaching it. And let's look at how this started. So reminders for questions, recurrent questions in Basecamp are sent out through this reminder delivery class. And deliveries are this encapsulation of the different ways we want to deliver notifications to people. That can be through email, it can be through push notifications on native applications, or it can be through the browser and the notification system there. Doesn't really matter. What's interesting here is how we're trying to figure out whether to deliver something or not. Well, the first thing in this pull request to look at is, so we have this reminder delivery, which is a generic concept. It's not specific to any of the individual data types we have in Basecamp. It's not specific to questions, it's not specific to approvals, which is another part of the system that uses reminders for deliveries. But the first obvious way to make this change, to simply say, well, if this question has already been answered, we shouldn't send the delivery, is of course to go straight to the sources, to go straight to this reminder delivery and try to add in a conditional, which is exactly where this pull request started. You see, we're adding in basically a method to check on whether we should deliver this reminder delivery, which is overriding a predicate method from the delivery superclass and basically just adding to it, saying, well, all these rules about whether we should deliver something or not, I'll take these from the superclass and then I'll add this notion of the question answered. And we don't want to deliver if the question's already been answered. So here we call a piece of code to, first of all, type check, is the recording we're working with, is that a question? Is the thing we're trying to deliver a reminder for, is that a question? If so, check if that question's already been answered. And we've added this lookup method, for, to basically just do that lookup for the entry, for the reminder, and then be able to interrogate whether that answer recording exists. Well, the first thing to notice here, the first thing that I noticed when I had a look at this was, the question is a specific data type. Reminder delivery is a generic concept. There's already a bit of a tension here when we introduce conditionals for specific types higher up in the hierarchy at a generic level. That would be the first place I think that we should have a look at, can we do that in a different way? Can we basically remove the knowledge, the type check for the question from within this delivery class and move it somewhere else where reminder delivery does not need to know the specifics of how a question is sent reminders or not, what the check itself is, should the check live somewhere else? The first instinct here would be to move this check to the class where these questions should be answered, to the question class, the answering classes. That is the part of the hierarchy, of the class hierarchy that we have, that should be responsible for making these determinations. So this was the first commit on the pull request. And we had a chat about this and we figured, let's try to move this somewhere else. And we ended up with then taking away basically what we had just done, thinking about, oh well, actually we can remove these specific predicates from the reminder delivery class and we can move that consideration somewhere else. We can move it all the way to the reminder class first of all. We have all these checks on the reminder itself, whether it's deliverable, which is a question that's asked even before the reminder is passed to the reminder delivery class. We check whether this reminder is actually deliverable. And we have these things such as, is the reminder scheduled, is it an eligible recording, which is things like checking the status of it, whether it has been trashed or not trashed, whether the remindee is eligible. If you have a reminder set up for someone who's been deleted from the system, we shouldn't be sending emails and notifications to people who've been deleted from the system. So that's also something that's an eligibility check. And then we add this idea of pertinent. Is the reminder pertinent? And we'll come back to the specific word that was chosen for that in just a second, but the check here for whether the reminder is pertinent also shouldn't be at or answered by the reminder itself. You want to answer that question from what the reminder is about. What are we trying to remind the user about? Well, as I said, we have different specific classes that we remind users about. One is these answers or rather these questions. And another is approvals when you're dealing with clients. So we want to abstract this notion that whether a reminder is pertinent or not and push it as far down as the hierarchy as we can, get to the most concrete level possible. And well, that concrete level is the question itself, right? It's natural for the question to know whether the question is still pertinent for this reminder. So we sort of do this level of indirection. We pass the reminder itself to the recordable, which is in this case is the question, and let the question then answer whether there's already an answer for this question, right? We actually have another class for this, which is the entry, which is the one that actually ends up having the lookup method for this, which is the one we just looked at before. But as you can see, we've taken the specific implementation of how to look this up and we've removed it from the generic level and we pushed it all the way down. We've replaced the check for whether a reminder is pertinent or not in the delivery class with basically just indirection, with message passing. Let's use a class hierarchy. Let's use polymorphism rather than sort of a type check. And this is one of those standard refactorings in object-oriented systems that you see over and over again in all sorts of different ways. As soon as you see type checks, it's a smell and it's an indication that you can replace that type check with message passing instead, right? And that you can then push down the responsibility of actually answering the question further down the chain. And what's interesting here is when you look at the two pieces of code, the original is actually clearer, right? All the information is gathered at the point where this delivery is happening. So if you just looked at the addition of these two additional methods, in some ways it's clearer than having the responsibility for answering this question be diffused across multiple objects. But the fact is the reminder delivery should be on its own change schedule. It shouldn't be changing when we're changing the strategy for figuring out whether a question has been answered or not. That could be, for example, has this question been answered today? Has it been answered yesterday? What is the scope of which we're looking for when we're interrogating this question? And there's always different ways that we would want to change that in the future. The reminder delivery is this generic class. Why should that be changing on that schedule, right? So this is one of those motivations where you're trying to keep parts of the system that are generic, stable, and as the system evolves, we might add a different data type in addition to the approvals and the questions that also need to be able to have reminders and also need to be able to say that the reminder is no longer pertinent. And all that logic should live with the class itself. And then finally, as we went through this pull request, we ended up thinking about this idea of pertinent. I initially liked the word, but Tom came up with something even simpler, which was basically just needed, right? Which is simpler language and actually more closer to casual use and casual vocabulary. Does this thing need a reminder is something you'd say, right? I think that's a good example of also picking not just an adequate word for what this method should be, but something that's as close as possible to the domain vocabulary that you would use in common conversation about this. And then finally, I left a note on the pull request about the fact that we're using this lookup method, the static lookup method on the entry to figure out whether there's an answer recording. And there's this consideration here, just as an aside, where we're basically using not, right? Like a reminder is needed if there's not already an answer for that question. Well, the not is kind of separated from the method call itself. If you look at the length of this line, the bulk of the line is about, well, digging down through a module hierarchy to go from question to answer to entry, then calling this lookup method for the reminder, and then calling sort of the actuality here, this we really want, which is the answer recording. And that's pretty far removed from the not, from the exclamation point, right? So rather than use negation this way, one way of sort of bringing things closer together is to use the Ruby method of blank, which does the same thing, and it's actually longer, and it's for sure is slower, but it's easier to read, right? And it reads in a natural order where you don't have to sort of remember, oh, we're nodding this whole thing, and then you're reading it through. Anyway, just a small example of how we try to evolve the system in a way where we're thinking about the impact that we leave, thinking about what's generic versus what's specific, and trying to push down the behavior that is specific to specific classes as far down as we possibly can get it. And then hopefully as we evolve the system over many years, we won't get these mega classes that aren't large because they do a lot of stuff, but because they have a lot of type text that sort of have exceptions for different objects. Push that old stuff down to the objects and let it live there, and you'll have a cleaner system.
